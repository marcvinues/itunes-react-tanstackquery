adjunto te envío info, de manera extra oficial, por si te ayuda con la prueba: 
1.Un buen readme explicando tecnologías, arquitecturas y patrones utilizados, ejemplo de 
los tests, además de cosas que debe tener un readme (es una muy buena oportunidad y 
se valora altamente la explicación de las decisiones de diseño tomadas, ya que esto 
ayuda a comprender la lógica que has seguido para la toma de decisiones, pudiendo 
remarcar y demostrar así el seniority sobre la materia): 
2.Claridad del código, se tiene en cuenta lo fácil que resulte leerlo y entenderlo 
(utilizando principios SOLID): 
3.Número de alertas que tenga cuando se ejecute un linter y que tenga un formatter:  
4.Separación en capas y que cada capa contenga únicamente su responsabilidad, explicar 
en el readme la arquitectura elegida y el porqué). (importante que el diseño sea 
escalable y modular): 
5.Consola limpia de errores: 
6.El diseño es responsive y se hace uso desde cero de CSS (para demostrar el dominio del 
mismo): 
7.Uso de las herramientas que proporciona Github o similares para la gestión del código 
(utilizar nomenclatura estándar de commits, ramas, etc): 
8.Que pasen correctamente los tests para ver el desarrollo del mismo: 
9.Que la solución sea modular, basada en componentes (explicar en el readme el porqué 
se ha tomado la decisión de dividir en esos componentes): 
10.Uso de Webpack o similar para la solución al completo: 
11.Implementación de custom hooks: 
12.Uso de Typescript con tipado completo en toda la aplicación: 
13.Se utilizan componentes from scratch: 
14.Uso de caché para aumentar la eficiencia (explicar en el readme qué mejoras se 
consiguen y la estrategia a seguir): 
15.Diseño fiel al propuesto: 
16.Modo desarrollo en el que se sirvan los assets sin minimizar (pueden estar 
concatenados) y otro modo producción donde se deben servir los assets concatenados y 
minimizados: 
17.Cumple con todos los requisitos pedidos en los diferenets apartados de "Funcionalidad" 
de la prueba (sí/no por qué?): 
18.Cumple con los requisitos de:  
a.No usar librerías de componentes como antd, reactstrap, materialui etc... 
b.Los componentes deben ser creados desde cero por ti mismo. 
c.Para la gestión de estado, usar ContextAPI de React 
19.¿Se han aplicado las siguientes mejoras?: 
a.La aplicación puede estar desplegada: 
b.Uso de SSR (Es posible usar Next.js): -> requerido?
c.Se valorará el uso de variables CSS: 
20.Que el ejercicio se pueda probar y cumpla exactamente con lo que se pide 
”Requerimientos del enunciado” (se puede extender funcionalidad, pero nunca debe 
comprometer o modificar el funcionamiento principal):



Hola Consuelo,

puedes comentarle al candidato que no es necesario usar Next.js.
La prueba está pensada como una SPA en React, con rutas cliente y build tool tipo Webpack o Vite.

No obstante, si el candidato se siente más cómodo con Next.js y mantiene el comportamiento de SPA (navegación cliente, caché, Context API, etc.), también es válido y se valorará como un plus, pero no es un requisito ni afecta a la nota base
03:34 PM
Hola Consuelo,

puedes comentarle al candidato que no es necesario usar Next.js.
La prueba está pensada como una SPA en React, con rutas cliente y build tool tipo Webpack o Vite.

No obstante, si el candidato se siente más cómodo con Next.js y mantiene el comportamiento de SPA (navegación cliente, caché, Context API, etc.), también es válido y se valorará como un plus, pero no es un requisito ni afecta a la nota base
03:45 PM
Hola Consuelo,

puedes comentarle al candidato que no es necesario usar Next.js.
La prueba está pensada como una SPA en React, con rutas cliente y build tool tipo Webpack o Vite.

No obstante, si el candidato se siente más cómodo con Next.js y mantiene el comportamiento de SPA (navegación cliente, caché, Context API, etc.), también es válido y se valorará como un plus, pero no es un requisito ni afecta a la nota base
03:45 PM
Ningún archivo seleccionado




